### "Таблицы"

Есть строка source и задано число size, которое меньше её длины. Требуется проверить, нет ли таких двух 
подстрок source длины size, которые были равны.

#### Наивное решение
**Первое решение**, которое может прийти в голову, это собрать все подстроки заданной длины, сложить в список, 
а затем перебрать всевозможные пары этих подстрок для поиска совпадения:
Но такой алгоритм очень медленный:
- Сбор всех подстрок в список занимает O(n2): substring линейный относительно длины вырезаемого кусочка из-за 
  копирования символов в новую строку (т.е. условно O(n)), а вырезаем мы O(n) раз, вот и получается O(n) * O
  (n) = O(n2).
- Перебор всех пар подстрок занимает O(n3): количество пар у нас O(n2), а само посимвольное сравнение у нас 
  линейное, вот и получается O(n2) * O(n) = O(n3).
- В итоге имеем O(n2) + O(n3) = O(n3), что весьма затратно.

#### Решение на хешах
Ускорим этот алгоритим следующей идеей. Будем складывать подстроки не в список, а в хеш-сет. Перед добавлением 
элемента проверим, есть ли уже такой в нём или нет. Если есть, то мы нашли совпадение.
- Хешсет работает быстро, ему не нужно ничего перебирать, его проверка за O(1). Асимптотика этого алгоритма 
  будет быстрее - O(n2). Всё из-за медленного (линейного) вырезания подстроки из source и таким же линейным 
  подсчётом хеша для неё, который будет использовать хешсет.

#### Ещё быстрее
Давайте ускорим предыдущий алгоритм до линейной асимптотики. Реализация этих идей как раз и будет вашеим заданием.

Сперва выберем алгоритм хеш-функции. В рамках этой задачи мы будем работать с хешированием текста как с суммой кодов символов этого текста.
String s = "Hello"; // пример строки для расчёта хеша
int hash = 0;
for (int i = 0; i < s.length(); i++) {
    hash += s.charAt(i);
}
System.out.println("Хеш для '" + s + "' равен " + hash);

Теперь давайте создадим свой аналог String-а - LazyString. Отличаться он будет двумя принципиальными вещами:

1. Подстрока будет создаваться в большинстве случаев за O(1) вместо O(n)
2. Хеш для соседней подстроки можно будет получить из предыдущей за O(1), а не пересчитывать линейно.
Для того, чтобы взятие подстроки было за O(1), мы прежде всего не будем реально копировать символы этой 
подстроки в новый объект. Вместо этого, мы будем просто запоминать из какой строки мы хотели подстроку и на 
каком месте. Это можно назвать ленивостью нашей реализации класса для подстроки. Если нам понадобятся символы 
нашей подстроки, то мы просто заглянем в соответствующее место нашей исходной строки.

Также мы предоставим два способа создания нашей подстроки:

- Через конструктор public LazyString(String source, int start, int end), который запоминает нужное место и 
  считает и запоминает хеш подстроки (тк этому подсчёту придётся перебрать символы подстроки, то создание 
  через этот конструктор является линейным).
- Через вызов метода public LazyString shiftRight(), который вернёт подстроку, соседнюю на один шаг вправо от 
  той, у кого вы вызвали этот метод. Такое создание будет за O(1), тк нам нужно будет лишь сдвинуть границы 
  подстроки который мы запоминаем и пересчитать хеш на основе хеша предыдущей строки, для чего достаточно лишь 
  вычесть код выпавшего символа и прибавить код нового символа.

  **В итоге асимптотика улучшится до линейной, тк ленивый substring с подсчётом хеша на основе предыдущей подстроки работать будет гораздо быстрее**.